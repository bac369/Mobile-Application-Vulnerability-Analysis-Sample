# AppSec 4

## Task 0: Beginning Modifications
When I tried registering or logging in, the Giftcardsite app would crash. I looked at the logs and it turned that since I denied location permissions the app would experience a FATAL_ERROR. I fixed this by removing the lines dealing with location services in ProductScrollingActivity. After which I was successfully able to register and login.
![Pic2](/Report/Artifacts/bac369-t1a.png)

## Task 1
### Task 1a: What's the Difference

- 1
The two types of intenets are Implicit and Explicit. Implicit declares an action and expects another app to handle it. Explicit declares a specific target or resource to be used.
- 2
The more secure intent is Explicit because the developer chooses exactly what needs to be done and what is going to do it. Implicit intents are more likely to be exploited due to their openness.
- 3
The intent shown in [SecondFragment.kt](GiftcardSite/app/src/main/java/com/example/giftcardsite/SecondFragment.kt) is an implicit intent, since it is not specifying what activity to do.

- 4
The intent in [ThirdFragment.kt](GiftcardSite/app/src/main/java/com/example/giftcardsite/ThirdFragment.kt) is Explicit, since it is specifically asking to start the ProductScrolling activity.
- 5
The explicit intent in ThirdFragment.kt is more secure, for the same reasons as explained above.
![Pic2](/Report/Artifacts/bac369-t1b.png)

### Task 1b: Switching Intents
I chose to fix the less secure, Implicit intent SecondFragment.kt  by replacing it with the Explicit intent in ThirdFragment.kt. I removed `var intent = Intent(Intent.ACTION_VIEW)
                  intent.type = "text/giftcards_browse"
                        intent.data = Uri.parse("https:[//]nyuappsec].]com/api/index")` and replaced it with `var intent = Intent(activity, ProductScrollingActivity::class.java)`
This causes both login and register actions to result in the  `ProductScrollingActivity`. Since the SecondFragment.kt now uses an Explicit Intent it is more secure. As you can see below, the logs show a successful register with the text `Register Success. Boo.` and the user was brought to the ProductScrollingActivity.
![Pic2](/Report/Artifacts/bac369-t1c.png)
### Task 1c: Shutting Out the World
The [AndroidManifest.xml](GiftcardSite/app/src/main/AndroidManifest.xml) used intent filters to reach out to `nyuappsec[.]com`. To fix this I removed the `<intent-filter>` blocks from all activities except one, thereby removing the calls to `nyuappsec[.]com`. The only one I did not remove was to `.MainActivity.` since this is needed to start the app and also does not reach out to otehr applications.

## Task 2
## Task 3
- A.
   The system in place to use a card is vulnerable. The interaction between the app and the API is exploitable allowing a user to use another card than the system intended. Looking into [UseCard.kt](GiftcardSite/app/src/main/java/com/example/giftcardsite/ProductScrollingActivity.kt), I found the line `@PUT("/api/use/{card_number}") fun useCard(@Path("card_number") card_number: Int?, @Header("Authorization") authHeader: String): Call<Card?>`. This line sends a PUT request using only the `card_number` as means to auhorize which card is used.
Using this knowledge and HTTP Toolkit, I was able to intercept the PUT request sent to the server and modify it to use another card. The exploit was as simple modifying the reuqest URL. As you can see in the iamge below, the PUT request was originally for card id 509, but I changed the URL so it used 311 instead. This is confirmed as you can see in the Response body the card `id: 311` was used instead of 509.
- B
As the application stands, the only other value that can be used to authorize the usage of a proper, as in the intended card to be used owned by the current user, is the `authorization Token`. Currently there is no interaction between the app and the API server that uses this token to authorize card usage. The api server should have a system that uses the Token passed through the application to check that the current user and current session align with the card holder of the card attempting to be used. Based off the Usecard.kt code it looks like the token is being passed and the response and authentication should be all done server side. The API and server code needs to be modified. Modification of the app source code does not seem necessary, since it is essentially just parsing the response from the server to the user UI and the server is already recieving the card id and Token.
